# Chapter 0: 架构总览

## 模块定位

本章是 dartic 设计文档体系的入口和权威总览。定义项目的目标场景、性能目标、语言特性支持范围和编译执行模型，并提供跨章节依赖拓扑和阅读指引。关于项目定位、术语和架构分层图，详见 `ARCHITECTURE.md`。

## 文档导读

各章解决的核心问题及建议阅读顺序：

| 顺序 | Chapter | 核心问题 | 前置知识 |
|------|---------|---------|---------|
| 1 | Ch0（本章） | 整体架构、目标、约束 | 无 |
| 2 | Ch1 字节码 ISA | 指令如何编码和分类 | 无 |
| 3 | Ch2 对象模型 | 三栈、对象、帧的内存布局 | Ch1（指令格式） |
| 4 | Ch3 执行引擎 | 字节码如何执行 | Ch2（数据结构） |
| 5 | Ch5 编译器 | Kernel AST 如何变成字节码 | Ch1（目标指令集） |
| 6 | Ch4 互调 | 解释器与宿主 VM 如何互调 | Ch3（运行时 API） |
| 7 | Ch6 泛型 | 实化泛型如何实现 | Ch2（栈帧布局）、Ch5（类型传递） |
| 8 | Ch7 异步 | async/await 如何实现 | Ch3（分发循环） |
| 9 | Ch8 沙箱 | 如何保护宿主应用安全 | Ch3（fuel 机制） |

## 跨章节依赖拓扑

```
              Ch5 编译器
             ╱     ╲
            ▼       ▼
    Ch1 ISA ◄── Ch2 对象模型 ◄── Ch3 执行引擎 ◄── Ch7 异步
                    ▲                ▲    ▲
                    │                │     ╲
                    │          Ch4 互调    Ch8 沙箱
                    │                ▲
                    │                │
                    └──────── Ch6 泛型
```

箭头含义：`A ← B` 表示 B 依赖 A 的定义。

| 依赖关系 | 说明 |
|---------|------|
| Ch5 → Ch1 | 编译器生成 Ch1 定义的指令 |
| Ch5 → Ch2 | 编译器以 Ch2 数据结构为目标生成字节码 |
| Ch3 → Ch2 | 执行引擎使用 Ch2 定义的三栈模型和对象表示 |
| Ch4 → Ch3 | Bridge/Proxy 通过运行时 API 操作解释器对象 |
| Ch6 → Ch2 | 泛型类型信息存储在栈帧的 ITA/FTA 槽位中 |
| Ch6 → Ch3 | 泛型子类型检查由执行引擎中 INSTANCEOF/CAST 指令驱动 |
| Ch7 → Ch3 | 异步帧快照和恢复扩展分发循环 |
| Ch8 → Ch3 | 沙箱机制复用执行引擎的 fuel 和调用深度限制 |

## 核心目标场景

**热更新（Code Push）**：在 iOS 等禁止 JIT 的平台上，通过下发字节码实现应用逻辑的动态更新，无需重新发版。

**插件/脚本系统**：为 Dart/Flutter 应用提供安全、可控的第三方代码执行能力，支持插件化扩展和沙箱化脚本运行。

## 性能目标

目标为 AOT 原生代码的 **1/10+** 执行性能。达成路径：

- 寄存器式字节码（相比栈式减少约 46% 指令执行数）
- `Uint32List` 紧凑指令存储 + 稠密 opcode 跳转表分发
- 共享 Buffer 双视图值栈（Int64List / Float64List 无装箱数值运算）

### 场景化性能预期

| 场景 | 预估性能 | 关键瓶颈 |
|------|---------|---------|
| 纯算术/控制流 | 原生 1/3~1/5 | switch 分发（无 computed goto） |
| 混合业务逻辑 | 原生 1/10~1/20 | 方法分发 + 对象操作 |
| Flutter Widget build | 原生 1/10~1/30 | Bridge 调用 + 对象创建 |
| 框架交互密集 | 原生 1/20~1/50 | Bridge 调用 + Proxy 包装 |

### 性能天花板

| 限制 | 来源 | 可否突破 |
|------|------|---------|
| 无 computed goto | Dart 语言不支持 | 不可突破，约损失 20-30% |
| typed_data bounds check | Dart AOT 可能无法消除 | 部分缓解 |
| Proxy 包装/解包开销 | 每次跨边界传递需 Expando 查找 + 对象分配 | 部分缓解（热对象缓存命中率高） |

## Dart 语言特性支持范围

**支持**：Dart 3.x 核心语言特性，包括——
- 类、mixin、枚举、sealed class、extension methods
- 泛型（reified generics，含泛型类、泛型方法、泛型闭包）
- Pattern matching、Records、Switch expressions
- async/await、async*、sync* 生成器
- 闭包与上值捕获
- 空安全（Sound null safety）
- 操作符重载

**不支持**：
- `dart:isolate`（多 isolate 并发）
- `dart:ffi`（原生内存访问）
- `dart:mirrors`（运行时反射）
- `deferred as` 延迟加载

**设计决策依据**：isolate/ffi/mirrors 三者均需要 VM 层面的特殊支持，无法在纯 Dart 解释器中实现。deferred loading 需要运行时按需加载编译单元和维护库级别的加载状态机，复杂度高且业务场景中较少使用。排除后不影响绝大多数业务逻辑和 UI 代码的执行。Extension type 作为编译期零成本抽象在运行时不存在，由编译器在 Kernel→字节码阶段透明处理。

## 编译与执行模型

```
                    本机（开发/CI）                     设备端
                  ┌──────────────────┐              ┌─────────────────────┐
Dart 源码 ──CFE──► .dill (Kernel AST) ──dartic 编译器──► 字节码 (.darticb)     │
                  └──────────────────┘    │         │                     │
                                          │         │  dartic 运行时        │
                                          │         │  ┌───────────────┐  │
                                          │         │  │ 字节码加载     │  │
                                          ▼         │  │ 分发循环执行   │  │
                                    Bridge 代码      │  │ 宿主 VM 互调   │  │
                                    （自动生成）      │  └───────────────┘  │
                                                    └─────────────────────┘
```

**编译在本机完成**，编译时间不受限。可充分利用寄存器分配、闭包编译、按需 Bridge 生成等编译期处理。

**设备端仅执行**，加载预编译的字节码和 Bridge 代码，无需编译。

## 关键设计不变式

以下不变式贯穿整个设计，各章必须遵守：

1. **值栈/引用栈分离**：int/double/bool 走值栈（零装箱），其他类型走引用栈（参与 GC 追踪）。同一值栈槽位在活跃区间内只通过一种视图访问（Ch1、Ch2）
2. **ISA 定宽编码**：所有指令固定 32 位，`Uint32List` 存储。超出操作数范围时使用 WIDE 前缀扩展（Ch1）
3. **DarticType 驻留**：相同结构的类型共享唯一实例，`==` 退化为 `identical()`（Ch6）
4. **帧即续体**：DarticFrame 是 Dart 堆对象，异步挂起时快照栈数据到帧对象，恢复时在栈顶重新分配空间（Ch7）
5. **加载时验证，运行时零检查**：字节码在加载时完成全部静态验证，分发循环不执行边界检查（Ch8）
6. **GC 委托宿主**：解释器不实现自己的 GC，所有堆对象由宿主 Dart VM GC 管理（Ch3）

## 与现有方案的定位差异

| 维度 | dart_eval | d4rt | hetu_script | **dartic** |
|------|-----------|------|-------------|-----------|
| 输入 | Dart 源码 (analyzer) | Dart 源码 (自定义解析) | 自定义语言 | **Kernel .dill (CFE)** |
| 执行 | 栈式字节码 | AST 遍历 | 栈式字节码 | **寄存器式字节码** |
| 指令存储 | `List<EvcOp>` 对象列表 | AST 树 | 字节码 | **`Uint32List` 紧凑编码** |
| 泛型 | 部分支持，跨边界擦除 | 声称完整，边界处退化 | 完全擦除 | **延迟按需实化 + 按需 Bridge 生成** |
| async | 有限 | async/await | Future/async | **帧快照续体 + Completer 桥接** |
| 性能预期 | AOT 的 1/10~1/50 | AOT 的 1/50~1/100 | - | **AOT 的 1/10+** |

dartic 的核心差异化在于：使用 CFE 编译产出的 Kernel AST 作为输入（避免重新实现 Dart 解析器），寄存器式字节码 + 紧凑存储（减少指令数和内存开销），以及系统性的跨边界互调设计（含泛型和异步）。
