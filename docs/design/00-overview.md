# Chapter 0: 架构总览

## 项目定位

darti 是一个运行于 Dart VM 内部的自定义字节码解释器。以 Dart Kernel（.dill 文件）为输入，编译为寄存器式字节码，在纯 Dart 实现的运行时中执行，通过 Bridge 层与宿主 Dart VM 双向互调。

## 术语约定

| 术语 | 含义 |
|------|------|
| 宿主 VM / VM | 运行 darti 的 Dart VM 进程 |
| 解释器 | darti 字节码解释器 |
| Bridge | 预生成的宿主类子类，用于 extends/implements 宿主类型 |
| 代理（Proxy） | 运行时按需创建的包装对象（GenericProxy / CallbackProxy） |

## 核心目标场景

**热更新（Code Push）**：在 iOS 等禁止 JIT 的平台上，通过下发字节码实现应用逻辑的动态更新，无需重新发版。

**插件/脚本系统**：为 Dart/Flutter 应用提供安全、可控的第三方代码执行能力，支持插件化扩展和沙箱化脚本运行。

## 性能目标

目标为 AOT 原生代码的 **1/5 ~ 1/3** 执行性能。达成路径：

- 寄存器式字节码（相比栈式减少约 46% 指令执行数）
- `Uint32List` 紧凑指令存储 + 稠密 opcode 跳转表分发
- 内联缓存（IC）+ 指令快化（Quickening）
- 共享 Buffer 双视图值栈（Int64List / Float64List 无装箱数值运算）

## Dart 语言特性支持范围

**支持**：Dart 3.x 核心语言特性，包括——
- 类、mixin、枚举、sealed class、extension methods
- 泛型（reified generics，含泛型类、泛型方法、泛型闭包）
- Pattern matching、Records、Switch expressions
- async/await、async*、sync* 生成器
- 闭包与上值捕获
- 空安全（Sound null safety）
- 操作符重载

**不支持**：
- `dart:isolate`（多 isolate 并发）
- `dart:ffi`（原生内存访问）
- `dart:mirrors`（运行时反射）

**设计决策依据**：isolate/ffi/mirrors 三者均需要 VM 层面的特殊支持，无法在纯 Dart 解释器中实现。排除后不影响绝大多数业务逻辑和 UI 代码的执行。Extension type 作为编译期零成本抽象在运行时不存在，由编译器在 Kernel→字节码阶段透明处理，无需特殊设计。

## 编译与执行模型

```
                    本机（开发/CI）                     设备端
                  ┌──────────────────┐              ┌─────────────────────┐
Dart 源码 ──CFE──► .dill (Kernel AST) ──darti 编译器──► 字节码 (.dartib)     │
                  └──────────────────┘    │         │                     │
                                          │         │  darti 运行时        │
                                          │         │  ┌───────────────┐  │
                                          │         │  │ 字节码加载     │  │
                                          ▼         │  │ 分发循环执行   │  │
                                    Bridge 代码      │  │ 宿主 VM 互调   │  │
                                    （自动生成）      │  └───────────────┘  │
                                                    └─────────────────────┘
```

**编译在本机完成**，编译时间不受限。可充分利用 LSRA 寄存器分配、常量折叠、窥孔优化、死代码消除、按需 Bridge 生成等编译期优化。

**设备端仅执行**，加载预编译的字节码和 Bridge 代码，无需编译。

## 核心架构分层

```
┌──────────────────────────────────────────────────────┐
│  宿主 Dart VM                                         │
├──────────────────────────────────────────────────────┤
│  安全沙箱层  (Chapter 7)                               │
│  字节码验证 · 指令计数 · 调用深度限制                     │
├──────────────────────────────────────────────────────┤
│  异步子系统  (Chapter 6)                               │
│  帧快照续体 · Completer 桥接 · 协作调度                  │
├──────────────────────────────────────────────────────┤
│  泛型系统  (Chapter 5)                                 │
│  延迟按需实化 · RuntimeType 驻留 · 子类型缓存            │
├──────────────────────────────────────────────────────┤
│  编译器（离线）  (Chapter 4)                            │
│  Kernel 加载 · 作用域分析 · LSRA · 闭包编译 · 优化遍     │
├──────────────────────────────────────────────────────┤
│  Bridge / 互调层  (Chapter 3)                          │
│  Bridge 类 · 代理缓存 · 跨边界泛型 · 回调代理           │
├──────────────────────────────────────────────────────┤
│  运行时  (Chapter 2)                                   │
│  共享 Buffer 双视图栈 · 引用栈 · 分发循环 · IC · GC 集成 │
├──────────────────────────────────────────────────────┤
│  字节码 ISA  (Chapter 1)                               │
│  32 位定宽指令 · 类型特化操作码 · 稠密编号                │
└──────────────────────────────────────────────────────┘
```

## 与现有方案的定位差异

| 维度 | dart_eval | d4rt | hetu_script | **darti** |
|------|-----------|------|-------------|-----------|
| 输入 | Dart 源码 (analyzer) | Dart 源码 (自定义解析) | 自定义语言 | **Kernel .dill (CFE)** |
| 执行 | 栈式字节码 | AST 遍历 | 栈式字节码 | **寄存器式字节码** |
| 指令存储 | `List<EvcOp>` 对象列表 | AST 树 | 字节码 | **`Uint32List` 紧凑编码** |
| 泛型 | 部分支持，跨边界擦除 | 声称完整，边界处退化 | 完全擦除 | **延迟按需实化 + 按需 Bridge 生成** |
| async | 有限 | async/await | Future/async | **帧快照续体 + Completer 桥接** |
| 性能预期 | AOT 的 1/10~1/50 | AOT 的 1/50~1/100 | - | **AOT 的 1/5~1/3** |

darti 的核心差异化在于：使用 CFE 编译产出的 Kernel AST 作为输入（避免重新实现 Dart 解析器），寄存器式字节码 + 紧凑存储（减少指令数和内存开销），以及系统性的跨边界互调设计（含泛型和异步）。
